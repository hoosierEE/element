* Element
What: a dialect of K using CPU or GPU based on run-time data.

Why: fun?

How: CUDA/C++

Dream: fast kernel DSL language embedded in a distributed system.

** k crash course
K is a vector language descended from APL, with hints of lisp.

#+begin_src k
 1+2 3 4                  /vectors
3 4 5
 +\(1 2;3 4;5 6)          /adverbs modify verbs. "\" is "scan"
(1 2
 4 6
 9 12)
 -1_(+9(|+\)\1 1)1        /first 9 fibonacci numbers
1 1 2 3 5 8 13 21 34
 (-1_(+9(|+\)\1 1)1)      /same
 {-1_(+9(|+\)\1 1)1}[]    /anonymous function
 {-1_(+x(|+\)\1 1)1}[9]   /"x" is first parameter
 f:{-1_(+x(|+\)\1 1)1}[9] /save function as "f"
 f'2 8 9                  /apply f to each of 2, 8, and 9
(1 1
 1 1 2 3 5 8 13 21
 1 1 2 3 5 8 13 21 34)
#+end_src

** typical K features
Most Ks have:
- an interpreter
- dynamic typing
- eager evaluation
- simple scoping rules (names are exclusively local or global)
- basic interaction with the host system
  + =\cd= to change directory without leaving the interpreter
  + run commands on the host system like =\ls=, =\pwd=
  + built-in file and socket I/O
- a method for loading/executing other K scripts
- a handful of basic types: int, float, char, symbol, list, dict, function
- no user-defined types
- arithmetic operations defined for single values as well as collections. =1+2= is =3=, =1+2 0 3= is =3 1 4=
- structural operations on collections. =(1 2),`a`b= is =(1;2;`a;`b)=
- right-to-left evaluation, no operator precedence: =2*3+4= is =2*(3+4)=
- partial application or "projections" instead of closures: ={x+y+z}[1;;3]= is ={1+x+3}=

** Element is different from K
There are multiple K dialects with slightly different features.
Most Element features stem from [[https://codeberg.org/ngn/k][ngn/k]], but has some differences.

Planned features:
- [ ] implicit hardware acceleration by default
  + [ ] small data processed on one CPU
  + [ ] big irregular data processed on multiple CPUs
  + [ ] big regular data processed on GPU
- [ ] lexical scope
- [ ] closures
- [ ] string data type (distinct from "list of char") as in [[https://anaseto.codeberg.page/goal/][goal]]
- [ ] =x::y= declare/update mutable variable: =a::1; a::2= (ok, =a= is mutable)
- [ ] =x:y= declare immutable =b:1; b::2= (error, =b= is immutable!)

Aspirational features:
- [ ] module system: =require x=, =provide x=
- [ ] =\cd= etc. provided by REPL, not runtime

* Install
Compile for GPU with NVIDIA's =nvcc= compiler:
#+begin_src bash
cd element/src && make
./element
#+end_src

Or for CPU with =g++=:
#+begin_src bash
CPU=1 cd element && make
./element
#+end_src

* Why the name "Element"?
- chemistry puns: K is potassium, CUDA (Cu) is copper
- vector languages deal with "elements of a vector" frequently
- naming is hard

* Development Roadmap
This project is in the *experimental*, pre-alpha stage.
Some [[https://github.com/doctest/doctest/tree/master/doc/markdown#reference][doctest]] tests exist, but no coverage goals yet.

[0/3]
- [-] practice (Python) implementation
  - [X] lex/scan/tokenize
  - [ ] parse
  - [ ] codegen
- [-] serious (C++/CUDA) implementation
  - [X] lex/scan/tokenize
  - [ ] optimize
  - [ ] codegen
- [ ] stable release(s)
  - [ ] pick a version numbering system and stick to it
  - [ ] formal grammar
  - [ ] standard library
  - [ ] package management
