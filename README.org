* Element
What: a dialect of K using CPU or GPU based on run-time data.

Why: fun?

How: CUDA/C++

Dream: fast kernel DSL language embedded in a distributed system.

** k crash course
The K programming language is terse and suited to rapid prototyping and number crunching.
Commercial implementations are used by quants to make number go up.
Open source implementations are used by people who like Project Euler, code golf, and puzzle solving.
Both commercial and free versions of the language tend to attract programmers who appreciate a certain spare and severe kind of elegance.

Here's a gentle introduction:
#+begin_src k
/line comments begin with a single slash
a: "h"        /assign (a) the char 'h'
a: ,"g"       /(a) is mutable, now contains the string "g" thanks to enlist (,)
a: 5 + 2 3 0  /(a) is now a list of ints (7 8 5), showcasing dynamic typing
a[2]: 7 8 9   /the list is mutable
b: -          /we can assign an infix operator to a name...
2 b 3         /...but we can't call it like an infix operator (this is an error)
b[2;3]        /we can however use m-expression function call syntax (this returns -1)
-[2;3]        /this is the same as b:-; b[2;3]
c: b[10;a]    /c gets (3 2 1)
f:{x+1}       /f gets an anonymous function that returns its argument incremented by 1
f[41]         /returns 42
f:{[a] a+1}   /you can also name the function's arguments (this (a) is local)
g:{a:3;x+y-a} /(;) separates statements; functions return their last statement
g[5;1]        /returns 3
g[5;1 2]      /returns (3 4)
g[5 6;1 2]    /returns (3 5)
g[5 6;1 2 3]  /length error! (1 2 3 - 3) worked, but the lengths ((5 6)+(-2 -1 0)) don't match
#+end_src

Here's a more elaborate example, executed in the ngn/k REPL (note the single space prompt):

#+begin_src k
 *+|'10(|+\)\1 1  /the first 11 numbers of the fibonacci sequence
1 1 2 3 5 8 13 21 34 55 89
 f:{*+|'x(|+\)\1 1} /a function to generate the first x+1 numbers of fibonacci
 f'2 8 9  /apply f to each item in the list (2 8 9), producing a new list
(1 1 2
 1 1 2 3 5 8 13 21 34
 1 1 2 3 5 8 13 21 34 55)
#+end_src

** typical K features
Most Ks have:
- an interpreter
- dynamic typing
- eager evaluation
- simple scoping rules (global or local variables, no lexical scoping)
- basic interaction with the host system
  + =\cd= to change directory without leaving the interpreter
  + run commands through =/bin/sh= such as =\ls=, =\pwd=
  + built-in file and socket I/O
- a method for loading/executing other K scripts
- a handful of basic types: int, float, char, symbol, list, dict, function
- no user-defined types
- arithmetic operations defined for single values as well as collections =1+2 0 3= is =3 1 4=
- structural operations on collections
- right-to-left evaluation and no operator precedence: =2*3+4= is =2*(3+4)=
- partial application or "projections" instead of closures: ={x+y+z}[1;;3]= is ={1+x+3}=

** Element quirks
How Element diverges from "typical K":
- implicit hardware acceleration by default
  + small data processed on one CPU
  + larger or large and irregular data processed on multiple CPUs
  + really large and regular data processed on GPU
- lexical scope
- closures
- =\cd=, =\d=, =\l file.k= etc. provided by REPL, not runtime
- string data type (distinct from "list of char")
- =x::y= declare mutable, change =mut::1; mut::2 /okay=
- =x:y= declare immutable =imm:1; imm::2 /error=
- =>s= open =fd:>`"/path/to/file.txt"=
- =<s= close =<fd=

* Install
Compile for GPU with NVIDIA's =nvcc= compiler:
#+begin_src bash
cd element/src && make
./element
#+end_src

Or for CPU with =g++=:
#+begin_src bash
CPU=1 cd element && make
./element
#+end_src

* Development
This project is in the *experimental*, pre-alpha stage.
Some [[https://github.com/doctest/doctest/tree/master/doc/markdown#reference][doctest]] tests exist, but no coverage goals yet.

Why the name "Element"?
- chemistry puns: K is potassium, CUDA (Cu) is copper
- vector languages deal with "elements of a vector" frequently
- naming is hard

